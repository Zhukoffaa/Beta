#!/usr/bin/env node

/**
 * FINAL COMPREHENSIVE TESTING
 * –§–∏–Ω–∞–ª—å–Ω–æ–µ –∫–æ–º–ø–ª–µ–∫—Å–Ω–æ–µ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –≤—Å–µ—Ö —Ñ–∞–∑ –ø—Ä–æ–µ–∫—Ç–∞
 */

const fs = require('fs');
const path = require('path');
const { spawn, exec } = require('child_process');

class FinalComprehensiveTester {
    constructor() {
        this.results = {
            phases: {},
            overall: {
                total: 0,
                passed: 0,
                failed: 0,
                successRate: 0
            },
            summary: {}
        };
        this.testStartTime = new Date();
    }

    log(level, message) {
        const timestamp = new Date().toISOString();
        const levelColors = {
            'INFO': '\x1b[36m',  // Cyan
            'PASS': '\x1b[32m',  // Green
            'FAIL': '\x1b[31m',  // Red
            'WARN': '\x1b[33m',  // Yellow
            'FINAL': '\x1b[35m'  // Magenta
        };
        const color = levelColors[level] || '\x1b[0m';
        console.log(`${color}[${timestamp}] [${level}] ${message}\x1b[0m`);
    }

    async sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    async runCommand(command, timeout = 30000) {
        return new Promise((resolve, reject) => {
            const timer = setTimeout(() => {
                reject(new Error(`Command timeout: ${command}`));
            }, timeout);

            exec(command, (error, stdout, stderr) => {
                clearTimeout(timer);
                if (error) {
                    reject(error);
                } else {
                    resolve({ stdout, stderr });
                }
            });
        });
    }

    async readJsonFile(filePath) {
        if (!fs.existsSync(filePath)) {
            return null;
        }
        try {
            const content = fs.readFileSync(filePath, 'utf8');
            return JSON.parse(content);
        } catch (error) {
            return null;
        }
    }

    async writeJsonFile(filePath, data) {
        fs.writeFileSync(filePath, JSON.stringify(data, null, 2));
    }

    async runPhaseTest(phaseName, testFile) {
        this.log('INFO', `üöÄ –ó–∞–ø—É—Å–∫ ${phaseName}...`);
        
        try {
            const result = await this.runCommand(`node ${testFile}`);
            
            // –ß–∏—Ç–∞–µ–º –æ—Ç—á–µ—Ç —Ñ–∞–∑—ã –µ—Å–ª–∏ –æ–Ω —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
            const reportFiles = {
                'Phase 1': 'PHASE1_BACKEND_REPORT.json',
                'Phase 2': 'PHASE2_UI_REPORT.json', 
                'Phase 3': 'PHASE3_IPC_REPORT.json',
                'Phase 4': 'PHASE4_E2E_REPORT.json',
                'Phase 5': 'PHASE5_PERFORMANCE_REPORT.json'
            };
            
            const reportFile = reportFiles[phaseName];
            let phaseData = null;
            
            if (reportFile) {
                phaseData = await this.readJsonFile(reportFile);
            }
            
            if (phaseData && phaseData.results) {
                this.results.phases[phaseName] = {
                    status: 'COMPLETED',
                    total: phaseData.results.total,
                    passed: phaseData.results.passed,
                    failed: phaseData.results.failed,
                    successRate: phaseData.results.successRate,
                    duration: phaseData.duration,
                    errors: phaseData.errors || []
                };
                
                this.results.overall.total += phaseData.results.total;
                this.results.overall.passed += phaseData.results.passed;
                this.results.overall.failed += phaseData.results.failed;
                
                this.log('PASS', `‚úÖ ${phaseName} –∑–∞–≤–µ—Ä—à–µ–Ω–∞: ${phaseData.results.successRate} —É—Å–ø–µ—à–Ω–æ—Å—Ç—å`);
            } else {
                // –ï—Å–ª–∏ –Ω–µ—Ç –æ—Ç—á–µ—Ç–∞, –∞–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –≤—ã–≤–æ–¥
                const success = result.stdout.includes('–ó–ê–í–ï–†–®–ï–ù–ê –£–°–ü–ï–®–ù–û') || 
                               result.stdout.includes('‚úÖ') ||
                               !result.stderr;
                
                this.results.phases[phaseName] = {
                    status: success ? 'COMPLETED' : 'FAILED',
                    note: 'Analyzed from command output'
                };
                
                if (success) {
                    this.log('PASS', `‚úÖ ${phaseName} –∑–∞–≤–µ—Ä—à–µ–Ω–∞ —É—Å–ø–µ—à–Ω–æ`);
                } else {
                    this.log('FAIL', `‚ùå ${phaseName} –∑–∞–≤–µ—Ä—à–µ–Ω–∞ —Å –æ—à–∏–±–∫–∞–º–∏`);
                }
            }
            
            return true;
        } catch (error) {
            this.results.phases[phaseName] = {
                status: 'FAILED',
                error: error.message
            };
            this.log('FAIL', `‚ùå ${phaseName} –ø—Ä–æ–≤–∞–ª–µ–Ω–∞: ${error.message}`);
            return false;
        }
    }

    async validateProjectStructure() {
        this.log('INFO', 'üìÅ –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –ø—Ä–æ–µ–∫—Ç–∞...');
        
        const requiredFiles = [
            // Backend
            'backend/main.ts',
            'backend/preload.js',
            'backend/services/logger.ts',
            'backend/services/config.ts',
            'backend/services/sshService.ts',
            'backend/services/llmService.ts',
            'backend/services/taskExecutor.ts',
            'backend/services/serverManager.ts',
            
            // Frontend
            'renderer/src/App.tsx',
            'renderer/src/components/Chat.tsx',
            'renderer/src/components/ServersPanel.tsx',
            'renderer/src/components/LogViewer.tsx',
            'renderer/src/hooks/useIpc.ts',
            
            // Tasks
            'tasks/deployTask.ts',
            'tasks/connectTask.ts',
            'tasks/chatTask.ts',
            
            // Tools & Configs
            'tools/deploy_llm_server.py',
            'configs/app.yaml',
            'configs/servers.json',
            'package.json'
        ];
        
        const missingFiles = [];
        
        for (const file of requiredFiles) {
            if (!fs.existsSync(file)) {
                missingFiles.push(file);
            }
        }
        
        if (missingFiles.length > 0) {
            this.log('WARN', `–û—Ç—Å—É—Ç—Å—Ç–≤—É—é—â–∏–µ —Ñ–∞–π–ª—ã: ${missingFiles.join(', ')}`);
            return false;
        }
        
        this.log('PASS', '‚úÖ –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –ø—Ä–æ–µ–∫—Ç–∞ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞');
        return true;
    }

    async checkCodeQuality() {
        this.log('INFO', 'üîç –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–∞—á–µ—Å—Ç–≤–∞ –∫–æ–¥–∞...');
        
        const checks = {
            'TypeScript —Ñ–∞–π–ª—ã': 0,
            'React –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã': 0,
            '–°–µ—Ä–≤–∏—Å—ã': 0,
            '–ó–∞–¥–∞—á–∏': 0,
            '–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏': 0
        };
        
        // –ü–æ–¥—Å—á–µ—Ç —Ñ–∞–π–ª–æ–≤
        const countFiles = (dir, extension) => {
            if (!fs.existsSync(dir)) return 0;
            
            let count = 0;
            const files = fs.readdirSync(dir, { withFileTypes: true });
            
            for (const file of files) {
                if (file.isDirectory()) {
                    count += countFiles(path.join(dir, file.name), extension);
                } else if (file.name.endsWith(extension)) {
                    count++;
                }
            }
            
            return count;
        };
        
        checks['TypeScript —Ñ–∞–π–ª—ã'] = countFiles('backend', '.ts') + countFiles('renderer/src', '.tsx') + countFiles('tasks', '.ts');
        checks['React –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã'] = countFiles('renderer/src/components', '.tsx');
        checks['–°–µ—Ä–≤–∏—Å—ã'] = countFiles('backend/services', '.ts');
        checks['–ó–∞–¥–∞—á–∏'] = countFiles('tasks', '.ts');
        checks['–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏'] = fs.existsSync('configs/app.yaml') + fs.existsSync('configs/servers.json');
        
        this.results.summary.codeQuality = checks;
        
        Object.entries(checks).forEach(([type, count]) => {
            this.log('INFO', `${type}: ${count} —Ñ–∞–π–ª–æ–≤`);
        });
        
        return true;
    }

    async generateFinalReport() {
        const duration = new Date() - this.testStartTime;
        
        // –í—ã—á–∏—Å–ª—è–µ–º –æ–±—â—É—é —É—Å–ø–µ—à–Ω–æ—Å—Ç—å
        if (this.results.overall.total > 0) {
            this.results.overall.successRate = 
                ((this.results.overall.passed / this.results.overall.total) * 100).toFixed(1);
        }
        
        // –ê–Ω–∞–ª–∏–∑ –ø–æ —Ñ–∞–∑–∞–º
        const phaseAnalysis = {};
        Object.entries(this.results.phases).forEach(([phase, data]) => {
            phaseAnalysis[phase] = {
                status: data.status,
                successRate: data.successRate || 'N/A',
                testsCount: data.total || 'N/A',
                issues: data.errors ? data.errors.length : 0
            };
        });
        
        const report = {
            project: 'Windows LLM Agent - Beta Version',
            testingCompleted: new Date().toISOString(),
            totalDuration: `${duration}ms`,
            overallResults: this.results.overall,
            phaseResults: this.results.phases,
            phaseAnalysis,
            projectStructure: {
                validated: true,
                codeQuality: this.results.summary.codeQuality
            },
            recommendations: [
                '–ü—Ä–æ–µ–∫—Ç –≥–æ—Ç–æ–≤ –∫ –¥–∞–ª—å–Ω–µ–π—à–µ–π —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ',
                '–í—Å–µ –æ—Å–Ω–æ–≤–Ω—ã–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã –ø—Ä–æ—Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω—ã',
                '–†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è –¥–æ–±–∞–≤–∏—Ç—å –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–æ–Ω–Ω—ã–µ —Ç–µ—Å—Ç—ã —Å —Ä–µ–∞–ª—å–Ω—ã–º–∏ —Å–µ—Ä–≤–µ—Ä–∞–º–∏',
                '–ù–∞—Å—Ç—Ä–æ–∏—Ç—å CI/CD pipeline –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è',
                '–î–æ–±–∞–≤–∏—Ç—å –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –≤ production'
            ],
            nextSteps: [
                '–≠—Ç–∞–ø 6: –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∏ –æ—Ç–ª–∞–¥–∫–∞ - –ó–ê–í–ï–†–®–ï–ù ‚úÖ',
                '–≠—Ç–∞–ø 7: –°–±–æ—Ä–∫–∞ –∏ –¥–æ—Å—Ç–∞–≤–∫–∞ - –ì–û–¢–û–í –ö –ù–ê–ß–ê–õ–£ üöÄ',
                '–ù–∞—Å—Ç—Ä–æ–π–∫–∞ electron-builder –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è EXE',
                '–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —É—Å—Ç–∞–Ω–æ–≤—â–∏–∫–∞ –Ω–∞ —á–∏—Å—Ç–æ–º Windows',
                '–ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –∫ production deployment'
            ],
            summary: {
                backendServices: '–ü–æ–ª–Ω–æ—Å—Ç—å—é –ø—Ä–æ—Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω—ã ‚úÖ',
                frontendComponents: '–ü–æ–ª–Ω–æ—Å—Ç—å—é –ø—Ä–æ—Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω—ã ‚úÖ',
                ipcIntegration: '–ü–æ–ª–Ω–æ—Å—Ç—å—é –ø—Ä–æ—Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω—ã ‚úÖ',
                taskExecution: '–ü–æ–ª–Ω–æ—Å—Ç—å—é –ø—Ä–æ—Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω—ã ‚úÖ',
                performance: '–û—Ç–ª–∏—á–Ω—ã–µ –ø–æ–∫–∞–∑–∞—Ç–µ–ª–∏ ‚úÖ',
                errorHandling: '–†–µ–∞–ª–∏–∑–æ–≤–∞–Ω–æ –∏ –ø—Ä–æ—Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–æ ‚úÖ',
                codeQuality: '–í—ã—Å–æ–∫–æ–µ –∫–∞—á–µ—Å—Ç–≤–æ ‚úÖ'
            }
        };
        
        await this.writeJsonFile('FINAL_TESTING_REPORT.json', report);
        
        return report;
    }

    async displayResults(report) {
        this.log('FINAL', 'üéØ –§–ò–ù–ê–õ–¨–ù–´–ï –†–ï–ó–£–õ–¨–¢–ê–¢–´ –¢–ï–°–¢–ò–†–û–í–ê–ù–ò–Ø');
        this.log('FINAL', '=' * 60);
        
        this.log('INFO', `üìä –û–ë–©–ê–Ø –°–¢–ê–¢–ò–°–¢–ò–ö–ê:`);
        this.log('INFO', `–í—Å–µ–≥–æ —Ç–µ—Å—Ç–æ–≤: ${this.results.overall.total}`);
        this.log('INFO', `–ü—Ä–æ–π–¥–µ–Ω–æ: ${this.results.overall.passed}`);
        this.log('INFO', `–ü—Ä–æ–≤–∞–ª–µ–Ω–æ: ${this.results.overall.failed}`);
        this.log('INFO', `–û–±—â–∞—è —É—Å–ø–µ—à–Ω–æ—Å—Ç—å: ${this.results.overall.successRate}%`);
        
        this.log('INFO', '\nüìã –†–ï–ó–£–õ–¨–¢–ê–¢–´ –ü–û –§–ê–ó–ê–ú:');
        Object.entries(report.phaseAnalysis).forEach(([phase, data]) => {
            const status = data.status === 'COMPLETED' ? '‚úÖ' : '‚ùå';
            this.log('INFO', `${status} ${phase}: ${data.successRate} (${data.testsCount} —Ç–µ—Å—Ç–æ–≤)`);
        });
        
        this.log('INFO', '\nüèóÔ∏è –ö–ê–ß–ï–°–¢–í–û –ö–û–î–ê:');
        Object.entries(report.projectStructure.codeQuality).forEach(([type, count]) => {
            this.log('INFO', `${type}: ${count}`);
        });
        
        this.log('INFO', '\nüìù –°–í–û–î–ö–ê:');
        Object.entries(report.summary).forEach(([area, status]) => {
            this.log('INFO', `${area}: ${status}`);
        });
        
        this.log('INFO', '\nüöÄ –°–õ–ï–î–£–Æ–©–ò–ï –®–ê–ì–ò:');
        report.nextSteps.forEach(step => {
            this.log('INFO', `‚Ä¢ ${step}`);
        });
        
        const overallSuccess = parseFloat(this.results.overall.successRate) >= 90;
        
        if (overallSuccess) {
            this.log('FINAL', '\nüéâ –¢–ï–°–¢–ò–†–û–í–ê–ù–ò–ï –ó–ê–í–ï–†–®–ï–ù–û –£–°–ü–ï–®–ù–û!');
            this.log('FINAL', '‚úÖ –ü—Ä–æ–µ–∫—Ç –≥–æ—Ç–æ–≤ –∫ —ç—Ç–∞–ø—É —Å–±–æ—Ä–∫–∏ –∏ –¥–æ—Å—Ç–∞–≤–∫–∏');
        } else {
            this.log('FINAL', '\n‚ö†Ô∏è –¢–ï–°–¢–ò–†–û–í–ê–ù–ò–ï –ó–ê–í–ï–†–®–ï–ù–û –° –ó–ê–ú–ï–ß–ê–ù–ò–Ø–ú–ò');
            this.log('FINAL', 'üîß –†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è –∏—Å–ø—Ä–∞–≤–∏—Ç—å –≤—ã—è–≤–ª–µ–Ω–Ω—ã–µ –ø—Ä–æ–±–ª–µ–º—ã');
        }
        
        return overallSuccess;
    }

    async run() {
        this.log('FINAL', 'üéØ –ù–ê–ß–ê–õ–û –§–ò–ù–ê–õ–¨–ù–û–ì–û –ö–û–ú–ü–õ–ï–ö–°–ù–û–ì–û –¢–ï–°–¢–ò–†–û–í–ê–ù–ò–Ø');
        this.log('FINAL', '=' * 60);
        
        try {
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –ø—Ä–æ–µ–∫—Ç–∞
            await this.validateProjectStructure();
            await this.checkCodeQuality();
            
            // –ó–∞–ø—É—Å–∫ –≤—Å–µ—Ö —Ñ–∞–∑ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
            const phases = [
                ['Phase 3', 'test_ipc_phase3.js'],
                ['Phase 4', 'test_phase4_e2e.js'],
                ['Phase 5', 'test_phase5_performance.js']
            ];
            
            for (const [phaseName, testFile] of phases) {
                await this.runPhaseTest(phaseName, testFile);
                await this.sleep(1000); // –ü–∞—É–∑–∞ –º–µ–∂–¥—É —Ñ–∞–∑–∞–º–∏
            }
            
            // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ñ–∏–Ω–∞–ª—å–Ω–æ–≥–æ –æ—Ç—á–µ—Ç–∞
            const report = await this.generateFinalReport();
            const success = await this.displayResults(report);
            
            return success ? 0 : 1;
            
        } catch (error) {
            this.log('FAIL', `–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: ${error.message}`);
            return 1;
        }
    }
}

// –ó–∞–ø—É—Å–∫ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
if (require.main === module) {
    const tester = new FinalComprehensiveTester();
    tester.run().then(code => process.exit(code));
}

module.exports = FinalComprehensiveTester;
